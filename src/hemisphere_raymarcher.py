import torch
import torch.nn.functional as F
import numpy as np
from utils import (
    RayBundle,
    softargmax3
)


###############################
# left-handed coordinate system
###############################
class HemisphereRaymarcher(torch.nn.Module):

    def __init__(self, args, max_lengths_from_spot = 1e3, threshold_intensity=0.01, device='cuda:0'):
        super().__init__()

        self.threshold_intensity = threshold_intensity     # represents a filtering threshold
        self.max_lengths_from_spot = max_lengths_from_spot    # represents an infinite depth
        self.device = device
        self.min_pos = args.min_pos
        self.max_pos = args.max_pos


    def forward(
        self,
        ray_bundle: RayBundle,
        ray_intensities: torch.Tensor  # [M, N, T]
    ):
        origins = ray_bundle.origins      # [M, N, 3]
        directions = ray_bundle.directions   # [M, N, 3]
        lengths = ray_bundle.lengths      # [M, N, T]

        noise_filter_mask = (ray_intensities < self.threshold_intensity)
        ray_signals = ray_intensities.clone()    # for avoiding in-place operation of auto-grad variable
        ray_signals[noise_filter_mask] = 0.0     # eliminates noise

        lengths[..., -1] = self.max_lengths_from_spot

        # differentiable version of depth finding with softargmax function
        lengths_taken = softargmax3(ray_signals, lengths)

        ########################################
        # surf_pos: [M, N, 3]  
        ########################################
        lengths_taken_broadcast = torch.stack([lengths_taken, lengths_taken, lengths_taken], dim=2)
        surf_pos = origins + lengths_taken_broadcast * directions
        
        ########################################
        # surf_normals: [M, N, 3]
        ########################################
        N = surf_pos.shape[1]
        n = int(np.sqrt(N))
        surf_pos = surf_pos.reshape(surf_pos.shape[0], n, n, 3)

        # normal extraction by using normals from 2 triangles generated by nearest 4 points
        surf_center_pos = surf_pos[:, 1:-1, 1:-1, :]    # O point
        pts_R = surf_pos[:, :-2, 1:-1, :]
        pts_G = surf_pos[:, 1:-1, :-2, :]
        pts_B = surf_pos[:, 2:, 1:-1, :]
        pts_P = surf_pos[:, 1:-1, 2:, :]
        vec0 = pts_G - pts_B        # BG vector
        vec1 = pts_R - pts_G        # GR vector
        vec2 = pts_P - pts_R        # RP vector
        vec3 = pts_B - pts_P        # PB vector
        tmp_cross_vec01 = torch.cross(vec0, vec1, dim=3)
        norm_vec01 = F.normalize(tmp_cross_vec01, dim=-1)
        tmp_cross_vec23 = torch.cross(vec2, vec3, dim=3)
        norm_vec23 = F.normalize(tmp_cross_vec23, dim=-1)  
        norm_vec0123 = norm_vec01 + norm_vec23      # normal of ORG + normal of OBP
        surf_normals = F.normalize(norm_vec0123, dim=-1)

        surf_center_pos = surf_center_pos.reshape(surf_pos.shape[0], -1, 3)
        surf_normals = surf_normals.reshape(surf_normals.shape[0], -1, 3)

        return surf_center_pos, surf_normals    # [M, (n-2)^2, 3] under n=sqrt(N)


    def show_points(self, points):
        import matplotlib.pyplot as plt
        fig = plt.figure()
        ax = fig.add_subplot(projection='3d')
        ax.scatter(points[...,0], points[...,1], points[...,2], edgecolor='black', alpha=0.1)

        r, c = 24, 5
        ax.scatter(points[r,c,0], points[r,c,1], points[r,c,2], facecolor='red')
        r, c = 24, 10
        ax.scatter(points[r,c,0], points[r,c,1], points[r,c,2], facecolor='orange')
        r, c = 24, 15
        ax.scatter(points[r,c,0], points[r,c,1], points[r,c,2], facecolor='yellow')

        ax.set_xlim([-1.0, 1.0])
        ax.set_ylim([-1.0, 1.0])
        ax.set_zlim([-1.0, 1.0])
        ax.set_box_aspect([1,1,1])
        plt.show()
